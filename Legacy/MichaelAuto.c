#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S3,     Sonar,          sensorSONAR)
#pragma config(Sensor, S4,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     Shoulder,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Lift,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Spin,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     driveFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     driveFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     driveR,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     driveL,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-touchmux.h"
#include "Debug.c"
#include "Shiela.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int LEVEL_DEBUG = 0;
int LEVEL_WARN = 1;
int LEVEL_ERROR = 2;




task driveToRamp(){
	nxtDisplayClearTextLine(2);
	nxtDisplayClearTextLine(3);
	addDebug(0,"Back");
	motor[driveL] = -30;
  motor[driveFL] = -30;
  motor[driveR] = -30;
  motor[driveFR] = -30;
  wait1Msec(1000);
  addDebug(0,"Right");

  motor[driveL] = 30;
  motor[driveFL] = 30;
  motor[driveR] = -30;
  motor[driveFR] = -30;
  wait1Msec(2000);
  addDebug(0,"Foward");
  motor[driveL] = 100;
  motor[driveFL] = 100;
  motor[driveR] = 100;
  motor[driveFR] = 100;
  wait1Msec(2000);
  addDebug(0,"Done Driving on ramp.");
	stopMotors();
	StopTask(driveToRamp);
}
task driveToTouch(){
	int line = addDebug(0,"Driving to touch");
		char temp[50]  = "";
 	wait1Msec(1000);
	while(HTTMUXisActive(sideTouch, 1) != 1&&HTTMUXisActive(sideTouch, 4) != 1)
	{
			servo[wrist] = 100;

			for (int i = 1; i < 5; i++) {
      if (HTTMUXisActive(sideTouch, i)){
      	sprintf(temp, "Touch: %d", i);
        debug[i]=temp;
      }
      else{
      	sprintf(temp, "!Touch: %d", i);
        debug[i]=temp;
      }
    	}


			motor[driveL] = 30;
      motor[driveFL] = 30;

      motor[driveR] = 30;
      motor[driveFR] = 30;
      wait1Msec(500);
	}
	addDebug(0,"Done driving to touch");
	stopMotors();
	servo[hand] = 25;
				wait1Msec(500);
				servo[hand] = 50;
				wait1Msec(500);
				servo[hand] = 75;
				wait1Msec(500);
				servo[hand] = 50;
				wait1Msec(500);

	StartTask(driveToRamp);
	StopTask(driveToTouch);
}

task autoRaise(){
	//1050
	//Shoulder 2 is now lift.
	int line = addDebug(0,"AutoRaise");
	int line2 = addDebug(0,"Debug");
	while(true){
		char temp[200]  = "";
		sprintf(temp, "Raise: %d", nMotorEncoder[Shoulder]);
		changeDebug(line,temp);
		sprintf(temp, "Speed: %d", motor[Shoulder]);
		changeDebug(line2,temp);

		if(nMotorEncoder[Shoulder]<100)
		{
			motor[Shoulder] =  55;
		}
		else if(nMotorEncoder[Shoulder]<650)
		{
			motor[Shoulder] = 80;
		}
		else{
			motor[Shoulder] = 20;
			wait1Msec(100);
			wait1Msec(1000);
			stopMotors();
			StartTask(driveToTouch);
			StopTask(autoRaise);

		}
		wait1Msec(50);
		abortTimeslice();
	}

}
task main()
{
	nMotorEncoder[Shoulder] = 0;
  initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.
  servo[hand] = 50;
	StartTask(debugger);
  StartTask(autoRaise);
  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////
  ////                                                   ////
  ////    Add your robot specific autonomous code here.  ////
  ////                                                   ////
  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////

  while (true)
  {
  	wait1Msec(60);
  }
}
