#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     DBR,           tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     DFR,           tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     DFL,           tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     DBL,           tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorJ,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Motor,  mtr_S1_C4_1,    Collecter,            tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

task main(){
	const int THRESHOLD = 5;
	getJoystickSettings (joystick);

	//bool turbo = false;
	//waitForStart();   // wait for start of tele-op phase

	while(true)
	{
		/*if (joy1Btn(7)) {
			turbo = !turbo;
		}*/
      	/*motor[DFR] =  ((joystick.joy1_y1) - (joystick.joy1_x1) - (joystick.joy1_x2));
       	motor[DFL] = (-(joystick.joy1_y1) - (joystick.joy1_x1) - (joystick.joy1_x2))/2;
       	motor[DBR] = ((joystick.joy1_y1) + (joystick.joy1_x1) - (joystick.joy1_x2))/2;
       	motor[DBL] =  (-(joystick.joy1_y1) + (joystick.joy1_x1) - (joystick.joy1_x2))/2;/**/

       	float onex = joystick.joy1_x1;
       	float oney = joystick.joy1_y1;
       	float twox = joystick.joy1_x2;
       	float twoy = joystick.joy1_y2;

       	onex = ((onex/120)*(onex/120)*(onex/120))*128;
       	oney = ((oney/120)*(oney/120)*(oney/120))*128;
       	twox = ((twox/120)*(twox/120)*(twox/120))*128;
       	twoy = ((twoy/120)*(twoy/120)*(twoy/120))*128;


       	if(abs(onex)<6)onex=0;

       	if(abs(oney)<6)oney=0;


       	if(abs(twox)<16)twox=0;

       	if(abs(twoy)<16)twoy=0;

       	motor[DFR] = (oney - onex - twox)/2;
       	motor[DFL] = (-oney - onex - twox)/2;
       	motor[DBR] = (oney + onex - twox)/2;
       	motor[DBL] = (-oney + onex - twox)/2;


          if (joy1Btn(1))
          {
              motor[motorK] = 12.5;
          }
          else if (joy1Btn(4))
          {
              motor[motorK] = -25;
          }
          else
          {
              motor[motorK] = 0;
          }
  	}
}
